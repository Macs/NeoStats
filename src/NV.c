/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of NV.xs. Do not edit this file, edit NV.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "NV.xs"
#include "neostats.h"
#include "namedvars.h"
#undef _
#ifdef WIN32
#undef getpid
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

XS(XS_NeoStats__NV_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_DeleteNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_AddNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_EXISTS); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_FIRSTKEY); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_NEXTKEY); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_ModNode); /* prototype to pass -Wmissing-prototypes */
void Init_Perl_NV() {

        newXSproto("NeoStats::NV::new", XS_NeoStats__NV_new, __FILE__, "$$");
        newXSproto("NeoStats::NV::HashVars::DeleteNode", XS_NeoStats__NV__HashVars_DeleteNode, __FILE__, "$$");
        newXSproto("NeoStats::NV::HashVars::AddNode", XS_NeoStats__NV__HashVars_AddNode, __FILE__, "$$$");
        newXSproto("NeoStats::NV::HashVars::ModNode", XS_NeoStats__NV__HashVars_ModNode, __FILE__, "$$$");
        newXSproto("NeoStats::NV::HashVars::FETCH", XS_NeoStats__NV__HashVars_FETCH, __FILE__, "$$");
        newXSproto("NeoStats::NV::HashVars::EXISTS", XS_NeoStats__NV__HashVars_EXISTS, __FILE__, "$$");
        newXSproto("NeoStats::NV::HashVars::FIRSTKEY", XS_NeoStats__NV__HashVars_FIRSTKEY, __FILE__, "$");
        newXSproto("NeoStats::NV::HashVars::NEXTKEY", XS_NeoStats__NV__HashVars_NEXTKEY, __FILE__, "$$");
}

/* XXX TODO: implement svREADONLY */

HV *perl_encode_namedvars(nv_list *nv, void *data) {
	HV *ret;
	int i =0;
	ret = newHV();
	while (nv->format[i].fldname != NULL) {
		switch(nv->format[i].type) {
			case NV_PSTR:
			case NV_STR:
				hv_store(ret, nv->format[i].fldname, strlen(nv->format[i].fldname),
					newSVpv(nv_gf_string(data, nv, i), strlen(nv_gf_string(data, nv, i))), 0);
				break;
			case NV_INT:
			case NV_LONG:
				hv_store(ret, nv->format[i].fldname, strlen(nv->format[i].fldname),
					newSViv(nv_gf_int(data, nv, i)), 0);
				break;
			case NV_VOID:
			case NV_PSTRA:
				nlog(LOG_WARNING, "perl_encode_namedvars: void/string todo!");
				break;
		}
	i++;
	}
	return ret;
}

nv_item *perl_store_namedvars(nv_list *nv, HV *values) {
	int i, j;
    nv_item *item;
	SV **value;
	i = 0;
	j = 0;
	item = nv_new_item(nv);
	while (nv->format[i].fldname != NULL) {
		if (hv_exists(values, nv->format[i].fldname, strlen(nv->format[i].fldname))) {
			value = hv_fetch(values, nv->format[i].fldname, strlen(nv->format[i].fldname), FALSE);
		} else {
			i++;
			continue;
		}
		switch (nv->format[i].type) {
			case NV_PSTR:
			case NV_STR:
				nv_sf_string(item, nv->format[i].fldname, SvPV_nolen(*value));
				break;
			case NV_INT:
				nv_sf_int(item, nv->format[i].fldname, SvIV(*value));
				break;
			case NV_LONG:
				nv_sf_long(item, nv->format[i].fldname, SvIV(*value));
				break;
			case NV_VOID:
			default:
				printf("Value: Unhandled!\n");
				break;
		}
		i++;
	}
	return item;
}



#define	RETURN_UNDEF_IF_FAIL { if ((int)RETVAL < 0) XSRETURN_UNDEF; }

#line 108 "NV.c"
XS(XS_NeoStats__NV_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV_new)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::new(class, varname)");
    SP -= items;
    {
	char *	varname = (char *)SvPV_nolen(ST(1));
	char *	class = (char *)SvPV_nolen(ST(0));
#line 105 "NV.xs"
   HV        *tie;
   SV        *nv_link;
   HV        *tieref;
   nv_list   *nv;
#line 124 "NV.c"
#line 110 "NV.xs"
   nv = FindNamedVars(varname);
   if (!nv) {
	nlog(LOG_WARNING, "Perl NV: Can't find NamedVar list %s %s", varname, class);
     	tieref = (HV *)&PL_sv_undef;
   } else {
	/* tie the hash to the package (FETCH/STORE) below */
   	tie = newHV();
	tieref = (HV *)newRV_noinc((SV*)tie);
   	sv_bless((SV *)tieref, gv_stashpv("NeoStats::NV::HashVars", TRUE));
	hv_magic(tie, (GV*)tieref, 'P'); 
	/* this one allows us to store a "pointer" 
         */
   	nv_link = newSViv((int)nv);
   	sv_magic(SvRV(tieref), nv_link, '~', 0, 0);
   	SvREFCNT_dec(nv_link);
   }
   /* return the hash */
   EXTEND(SP,1);
   PUSHs(sv_2mortal((SV *)tieref));
#line 145 "NV.c"
	PUTBACK;
	return;
    }
}

XS(XS_NeoStats__NV__HashVars_DeleteNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_DeleteNode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::DeleteNode(self, key)");
    {
	SV *	self = ST(0);
	SV *	key = ST(1);
#line 138 "NV.xs"
   STRLEN        klen;
   MAGIC        *mg;
   nv_list	*nv;
   nv_item	*item;
#line 165 "NV.c"
	IV	RETVAL;
	dXSTARG;
#line 143 "NV.xs"
   RETVAL = (IV)-1;
   /* find our magic */
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("lost ~ magic"); }
   /* this is the nv_hash we are point at */
   nv = (nv_list *)SvIV(mg->mg_obj);
   item = nv_new_item(nv);
   /* make sure its a hash, not a list */
   if (nv->type == NV_TYPE_HASH) {
	/* get the "key" they want */
	item->index.key    = SvPV(key, klen);
	/* search for the key */
	item->type = nv->type;
   } else if (nv->type == NV_TYPE_LIST) {
	/* get the position */ 
	item->index.pos = SvIV(key);
	item->type = nv->type;
   }
   RETVAL = (IV)nv_update_structure(nv, item, NV_ACTION_DEL);
#line 188 "NV.c"
#line 163 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 191 "NV.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_AddNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_AddNode)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::AddNode(self, key, data)");
    {
	SV *	self = ST(0);
	SV *	key = ST(1);
	HV *	data;
#line 173 "NV.xs"
   STRLEN        klen;
   MAGIC        *mg;
   nv_list	*nv;
   nv_item	*item;
#line 212 "NV.c"
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVHV)
	    data = (HV*)SvRV(ST(2));
	else
	    Perl_croak(aTHX_ "data is not a hash reference");
#line 178 "NV.xs"
   RETVAL = (IV)-1;
   /* find our magic */
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("AddNode: lost ~ magic"); }
   /* this is the nv_hash we are point at */
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* encode the data into item */
   item = perl_store_namedvars(nv, data);
   if (item) {
	   /* make sure its a hash, not a list */
	   if (nv->type == NV_TYPE_HASH) {
		/* get the "key" they want */
		item->index.key    = SvPV(key, klen);
		item->type = nv->type;
	   } else if (nv->type == NV_TYPE_LIST) {
		/* add on a list, pos will always be -1, so ignore key */
		item->index.pos = -1;
		item->type = nv->type;
	   }
   }
   RETVAL = (IV)nv_update_structure(nv, item, NV_ACTION_ADD);
#line 242 "NV.c"
#line 200 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 245 "NV.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_ModNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_ModNode)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::ModNode(self, key, data)");
    {
	SV *	self = ST(0);
	SV *	key = ST(1);
	HV *	data;
#line 210 "NV.xs"
   STRLEN        klen;
   MAGIC        *mg;
   nv_list	*nv;
   nv_item	*item;
#line 266 "NV.c"
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVHV)
	    data = (HV*)SvRV(ST(2));
	else
	    Perl_croak(aTHX_ "data is not a hash reference");
#line 215 "NV.xs"
   RETVAL = (IV)-1;
   /* find our magic */
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("AddNode: lost ~ magic"); }
   /* this is the nv_hash we are point at */
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* encode the data into item */
   item = perl_store_namedvars(nv, data);
   if (item) {
	   /* make sure its a hash, not a list */
	   if (nv->type == NV_TYPE_HASH) {
		/* get the "key" they want */
		item->index.key    = SvPV(key, klen);
		item->type = nv->type;
	   } else if (nv->type == NV_TYPE_LIST) {
		/* add on a list, pos will always be -1, so ignore key */
		item->index.pos = SvIV(key);
		item->type = nv->type;
	   }
   }
   RETVAL = (IV)nv_update_structure(nv, item, NV_ACTION_MOD);
#line 296 "NV.c"
#line 237 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 299 "NV.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_FETCH)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::FETCH(self, key)");
    {
	SV *	self = ST(0);
	SV *	key = ST(1);
#line 253 "NV.xs"
   char         *k;
   STRLEN        klen;
   MAGIC        *mg;
   nv_list	*nv;
   void 	*data;
   int		pos, i;
   lnode_t 	*lnode;
#line 322 "NV.c"
	HV *	RETVAL;
#line 261 "NV.xs"
   RETVAL = (HV *)-1;
   /* find our magic */
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("lost ~ magic"); }
   /* this is the nv_hash we are point at */
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* make sure its a hash, not a list */
   if (nv->type == NV_TYPE_HASH) {
	   /* get the "key" they want */
	   k    = SvPV(key, klen);
	   /* search for the key */
	   data = hnode_find((hash_t *)nv->data, k);
	   if (!data) {
		RETVAL = (HV *)-1;
	   } else {
		RETVAL = (HV *)perl_encode_namedvars(nv, data);	   
	   }
   } else if (nv->type == NV_TYPE_LIST) {
	   /* get the position */
	   pos = SvIV(key);
	   lnode = list_first((list_t *)nv->data);;
	   if (!lnode) {
		RETVAL = (HV *)-1;
	   } else {
		   for (i = 0; i < pos; i++) {
				lnode = list_next((list_t *)nv->data, lnode);
		   }
		   if (lnode) {
			   RETVAL = perl_encode_namedvars(nv, lnode_get(lnode));
		   } else
			   RETVAL = (HV *)-1;
	  }
   }
#line 358 "NV.c"
#line 295 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 361 "NV.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_EXISTS); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_EXISTS)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::EXISTS(self, key)");
    {
	SV *	self = ST(0);
	SV *	key = ST(1);
#line 307 "NV.xs"
   HV   *hash;
   char *k;
   nv_list *nv;
   MAGIC        *mg;
   STRLEN        klen;
   char 	*data;
   int 		pos;
#line 385 "NV.c"
	bool	RETVAL;
#line 315 "NV.xs"
   RETVAL = 0;
   hash = (HV*)SvRV(self);
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("lost ~ magic"); }
   /* this is the nv_hash we are point at */
   k    = SvPV(key, PL_na);
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* make sure its a hash, not a list */
   if (nv->type == NV_TYPE_HASH) {
	   /* get the "key" they want */
	   k    = SvPV(key, klen);
	   /* search for the key */
	   data = hnode_find((hash_t *)nv->data, k);
	   if (!data) {
		RETVAL = 0;
	   } else {
		RETVAL = 1;
	   }
   } else if (nv->type == NV_TYPE_LIST) {
	   pos = SvIV(key);
	   if (pos > list_count((list_t *)nv->data)) 
		RETVAL = 0;
	   else
		RETVAL = 1;
   }
#line 413 "NV.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_FIRSTKEY); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_FIRSTKEY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::FIRSTKEY(self)");
    {
	SV *	self = ST(0);
#line 349 "NV.xs"
   HV *hash;
   MAGIC *mg;
   nv_list *nv;
   hnode_t *node;
#line 433 "NV.c"
	SV *	RETVAL;
#line 354 "NV.xs"
   RETVAL = &PL_sv_undef;
   hash = (HV*)SvRV(self);
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("lost ~ magic"); }
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* make sure its a hash, not a list */
   if (nv->type == NV_TYPE_HASH) {
	hash_scan_begin( &nv->iter.hscan, (hash_t *)nv->data);
	node = hash_scan_next(&nv->iter.hscan);
	nv->itercount = 0;
	if (!node) {
		RETVAL = &PL_sv_undef;
	} else {
		RETVAL = newSVpv(hnode_getkey(node), 0);
	}
   } else if (nv->type == NV_TYPE_LIST) {
	nv->iter.node = list_first((list_t *)nv->data);
	nv->itercount = 0;
	RETVAL = newSVpv("0", 0);
   }
#line 456 "NV.c"
#line 375 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 459 "NV.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_NeoStats__NV__HashVars_NEXTKEY); /* prototype to pass -Wmissing-prototypes */
XS(XS_NeoStats__NV__HashVars_NEXTKEY)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NeoStats::NV::HashVars::NEXTKEY(self, lastkey)");
    {
	SV *	self = ST(0);
#line 385 "NV.xs"
   HV *hash;
   MAGIC *mg;
   hnode_t *node;
   nv_list *nv;
   char tmpstr[BUFSIZE];
#line 480 "NV.c"
	SV *	RETVAL;
#line 391 "NV.xs"
   RETVAL = &PL_sv_undef;
   hash = (HV*)SvRV(self);
   mg   = mg_find(SvRV(self),'~');
   if(!mg) { croak("lost ~ magic"); }
   nv = (nv_list *)SvIV(mg->mg_obj);
   /* make sure its a hash, not a list */
   if (nv->type == NV_TYPE_HASH) {
	node = hash_scan_next(&nv->iter.hscan);
	nv->itercount++;
	if (!node) {
		RETVAL = &PL_sv_undef;
	} else {
		RETVAL = newSVpv(hnode_getkey(node), 0);
	}
   } else if (nv->type == NV_TYPE_LIST) {
	nv->itercount++;
	if (nv->itercount >= list_count((list_t *)nv->data)) {
		RETVAL = &PL_sv_undef;
	} else {
		ircsnprintf(tmpstr, BUFSIZE, "%d", nv->itercount);
		RETVAL =newSVpv(tmpstr,0);
	}
   }
#line 506 "NV.c"
#line 415 "NV.xs"
	RETURN_UNDEF_IF_FAIL;
#line 509 "NV.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_NeoStats__NV); /* prototype to pass -Wmissing-prototypes */
XS(boot_NeoStats__NV)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("NeoStats::NV::new", XS_NeoStats__NV_new, file, "$$");
        newXSproto("NeoStats::NV::HashVars::DeleteNode", XS_NeoStats__NV__HashVars_DeleteNode, file, "$$");
        newXSproto("NeoStats::NV::HashVars::AddNode", XS_NeoStats__NV__HashVars_AddNode, file, "$$$");
        newXSproto("NeoStats::NV::HashVars::ModNode", XS_NeoStats__NV__HashVars_ModNode, file, "$$$");
        newXSproto("NeoStats::NV::HashVars::FETCH", XS_NeoStats__NV__HashVars_FETCH, file, "$$");
        newXSproto("NeoStats::NV::HashVars::EXISTS", XS_NeoStats__NV__HashVars_EXISTS, file, "$$");
        newXSproto("NeoStats::NV::HashVars::FIRSTKEY", XS_NeoStats__NV__HashVars_FIRSTKEY, file, "$");
        newXSproto("NeoStats::NV::HashVars::NEXTKEY", XS_NeoStats__NV__HashVars_NEXTKEY, file, "$$");
    XSRETURN_YES;
}

